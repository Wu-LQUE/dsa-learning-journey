# 动态规划问题的核心
## 1.背包问题
背包问题的常规递归解法时间复杂度为指数级别，因为其中重复计算了一些子问题。实际上，我们可以用一个数组存储一些子问题的解，做记忆化搜索，此时时间复杂度已经(大多数情况)和动态规划相同了，两者的核心都是避免对重叠子问题的计算。
区别在于，记忆化搜索是自顶向下的，而动态规划是自底向上的，相当于两种算法是对同一棵递归树的不同表示。
>这棵树的存储在递归中表现为函数调用的栈(准确的说是state)，在动态规划中表现为dp表（通常是二维的）

状态转移方程实质描述了怎么由树的叶子节点产生一个共同的父节点的过程， 如**0-1背包问题**中，一个状态转移方程:

    dp[i][c] = max( dp[i-1][c], dp[i-1][c-cur_wgt] + cur_val );

这个方程说明了一个(i,c)处的节点的值是取 **子节点(i-1,c)** 和 **子节点(i-1,c-cur_wgt)+cur_val** 中的最大值，这(反向)对应递归代码

    int notPutI = recursion(i-1,c);
    int putI = recursion(i-1,c-cur_wgt) + cur_val;
    int mem[i][c] = max( notPutI, putI );

**综上，动态规划和记忆化搜索在本质上是相通的，它们都利用了“重叠子问题”和“最优子结构”这两个关键性质，并通过存储中间结果来避免重复计算。**

